#!/bin/sh
# Copyright 2016 The dev Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

#
# Shell Style Guide: https://google.github.io/styleguide/shell.xml
#
# dev_xxx: Framwork functions, declared in bin/dev.
# glb_xxx: Global variables, declared in bin/dev.
#
# opa_rem: Optional arguments description variables(readonly).
# opa_als: Alias of optional arguments(readonly).
# opa_fun_xxx: Optional arguments function.
#
# cfg_xxx: Configurations, declared in config file(readonly).
# cmd_xxx: Command function, declared in xxx.cmd files by user.
# xxx: Local varialbes, declared in xxx.cmd files by user. Declare
#      function-specific variables with local. Declaration and assignment
#      should be on different lines. for example:
#          local file
#          file="/path/to/file/name"
#      or (only in function)
#          declare file="/path/to/file/name"
#

# trace ERR through pipes
set -o pipefail

# set -e : exit the script if any statement returns a non-true return value
set -o errexit

declare glb_version="1.2"

# Run-state:
# 0:Not-run(readonly)
# 1:Run(alterable,local,default)
# 2:Run(readonly,local)
# 3:Run(readonly,remote)
declare -g glb_run=1 glb_run_dry=0 glb_run_compact=0 glb_run_sudo=0 glb_run_daemon=0

# Command file
declare -g glb_file glb_func glb_argv glb_user

# For option arguments
declare -Ag glb_run_nodes opa_rem opa_als

#
# Usage information.
#
dev_help_usage() {
    declare files="<cmd-file>"
    [ ! -z "$1" ] && files="$1"

    echo "Usage: dev [--[options [args]]] [prj] $files <cmd-func> [cmd-args] ..."
    echo "       dev [--[options [args]]] [args] ..."; echo
}

#
# List all options
#
dev_help_options() {
    echo "Optional arguments:"; echo
    dev_help_options_items |sort; echo
}

#
# List all options
#
dev_help_options_items() {
    declare opt sht als

    for als in "${!opa_als[@]}"; do
        opt="${opa_als[$als]}"
        [ "$opt" != "$als" ] && sht=", -$als" || sht=""
        echo -e "  --${opt//_/-}$sht \t ${opa_rem[$opt]}"
    done

    # for i in $(compgen -A function); do
    #     if [[ "${i:0:8}" == "opa_fun_" ]]; then
    #         opt="${i:8}"
    #     fi
    # done
}

#
# Usage:
#     dev_help_projects [cmd-file]
#
dev_help_projects() {
    declare prj ret wkdir
    if [[ $# -le 0 && "$glb_prj" == "dev" ]]; then
        echo "These are the all aviliable <prj>s:"; echo
        # List all projects
        for prj in "${!cfg_projects[@]}"; do
            ret="$ret $prj"
        done
        echo ${ret:1} |tr " " "\n" |column -c $(tput cols) |fmt; echo

        # List files in dev project
        dev_help_files $glb_base; return 0
    fi

    if [[ $# -le 0 ]]; then
        # List all cmd-file
        dev_help_files $glb_wkdir
    else
        # List all cmd-func
        dev_help_functions $glb_wkdir $1
    fi
}

#
# List all command files.
#
dev_help_files() {
    declare wkdir
    [ -z "$1" ] && wkdir="$glb_wkdir" || wkdir="$1"
    [ -z $wkdir ] && return 0
    echo "These are the all aviliable <cmd-file>s:"; echo

    declare ret
    ret="$ret $(dev_cmd_files $wkdir/cmd)"
    echo ${ret:1} |tr " " "\n" |column -c $(tput cols) |fmt; echo
}

#
# List all functions of included <cmd-file>s.
#
dev_help_functions() {
    declare wkdir cf
    [ -z "$1" ] && wkdir="$glb_wkdir" || wkdir="$1"
    [ -z "$2" ] && cf="$glb_file" || cf="$2"
    echo "These are the all aviliable <cmd-func>s:"; echo

    for i in $(compgen -A function); do
        if [[ "${i:0:4}" == "cmd_" ]]; then
            echo -e "  ${i:4} \t in $wkdir/cmd/$glb_file:$i()"
        fi
    done

    echo
}

#
# Recursively process subdirectories
#
dev_cmd_files() {
    for i in $(ls $1); do
        if [[ -d $1/$i ]]; then
            dev_cmd_files $1/$i $i/
        elif [[ "${i: -4}" == ".cmd" ]]; then
            echo "$2${i:0:-4}"
        fi
    done
}

#
# Usage:
#     dev_scp <user-host> <command>
#
dev_scp() {
    declare cmd="scp -i $glb_ssh_key -o StrictHostKeyChecking=no $@"
    echo "$cmd" && $cmd
}

#
# Usage:
#     dev_ssh <user-host> <command>
#
dev_ssh() {
    declare cmd="ssh -i $glb_ssh_key -o StrictHostKeyChecking=no $@"
    echo "$cmd" && $cmd
}

#
# Usage:
#     dev_dnf
#
dev_dnf() {
    # -4     Resolve to IPv4 addresses only.
    # --allowerasing
    #        Allow  erasing  of  installed  packages  to  resolve dependencies.
    declare cmd="sudo dnf -y --allowerasing -4 $@"
    echo "$cmd" && $cmd
}

#
# Usage:
#     dev_options
#
dev_options() {
    declare opt als ret

    for als in "${!opa_als[@]}"; do
        opt="${opa_als[$als]}"
        ret="$ret --${opt//_/-}" && [ "$opt" != "$als" ] && ret="$ret -$als"
    done

    echo "${ret:1}"
}

#
# Usage:
#     dev_completion [prj] [cmd-file]
#
dev_completion() {
    declare ret cur="${glb_argv:1}" key prj wkdir=$glb_base

    [ "${cur:0:1}" == "-" ] && dev_options && return 0

    # echo "Args:$@" >&2
    # echo "Cur:$cur" >&2
    if [[ $# -le 0 ]]; then
        # List all projects
        for prj in "${!cfg_projects[@]}"; do
            ret="$ret $prj"
        done

        # List files in dev project
        ret="$ret $(dev_cmd_files $glb_base/cmd | tr '\n' ' ')"
        echo "${ret:1}"; return 0
    fi

    # invalid prj
    if [ -z "${cfg_projects[$1]}" ]; then
        # List all cmd-func
        dev_load_files $glb_base $1
        for key in $(compgen -A function); do
            [ "${key:0:4}" == "cmd_" ] && ret="$ret ${key:4}"
        done
        echo "${ret:1}"; return 0
    fi

    wkdir="${cfg_projects[$1]}"

    if [[ $# -eq 1 && ! -z "$wkdir" ]]; then
        # List all cmd-file
        ret="$ret $(dev_cmd_files $wkdir/cmd | tr '\n' ' ')"
    elif [ $# -eq 2 ]; then
        # List all cmd-func
        dev_load_files $wkdir $2
        for key in $(compgen -A function); do
            [ "${key:0:4}" == "cmd_" ] && ret="$ret ${key:4}"
        done
    fi

    echo "${ret:1}"
}

#
# Usage:
#     dev_deploy
#
dev_deploy() {
    declare wkdir

    [ -z "$glb_argv" ] || [ "$glb_argv" == "dev" ] && wkdir="$glb_wkdir" || wkdir="${cfg_projects[$glb_argv]}"
    [ -z "$wkdir" ] && echo "Config error in $glb_base/etc/dev.conf" >&2 && return 1
    [ "${#glb_run_nodes[@]}" -le 0 ] && echo "Nodes is empty" >&2 && return 1

    declare cmd user host sudoer init_tar=/tmp/dev-init.tar

    cmd="mkdir -m 700 -p \$HOME/.ssh &&"
    cmd="$cmd cat > \$HOME/.ssh/authorized_keys &&"
    cmd="$cmd chmod 600 \$HOME/.ssh/authorized_keys"

    [ -f $init_tar ] && rm -f $init_tar

    cd $wkdir
    tar --exclude='./dev-init.tar' \
        --exclude='./*.sublime-*' \
        --exclude='./var/log' \
        --exclude='./var/tmp' \
        -cf $init_tar .

    for host in "${!glb_run_nodes[@]}"; do
        sudoer="${glb_run_nodes[$host]}"
        [ -z "$glb_user" ] && user="$sudoer" || user="$glb_user"

        # public key, remotely write to a file using SSH
        # It's will overwrite authorized_keys
        cat $glb_ssh_key.pub | dev_ssh $user@$host "$cmd"
        [ "$user" != "$sudoer" ] && dev_scp $glb_ssh_key $glb_ssh_key.pub $user@$host:\$HOME/.ssh
        dev_scp $init_tar $glb_base/bin/dev-installer $user@$host:/tmp
        dev_ssh $user@$host "/tmp/dev-installer $wkdir $sudoer"
    done

    rm -f $init_tar
}

#
# Usage:
#     dev_base
#
dev_base() {
    declare base="$0" cfg;
    [ -L "$base" ] && base=$(readlink -f $base); base=$(dirname $(realpath $base))
    if [ "$(basename $base)" == "bin" ]; then
        declare -gr glb_base="$(dirname $base)"
    else
        declare -gr glb_base="$base"
    fi

    for cfg in "$glb_base/dev.conf", "$HOME/.dev.conf", "$glb_base/etc/dev.conf"; do
        [ -f $cfg ] && . $cfg && break
    done

    # Private key: glb_ssh_key
    [ -z "$cfg_ssh_key" ] && declare -gr glb_ssh_key="$HOME/.ssh/id_rsa" || \
        declare -gr glb_ssh_key="$HOME/.ssh/$cfg_ssh_key"

    [ -f $glb_base/lib/options ] && . $glb_base/lib/options
}

#
# Usage:
#     dev_project <prj>
#
dev_prj() {
    [ ! -z "$glb_prj"] && return 1

    if [ "$1" == "dev" ]; then
        declare -gr glb_prj="dev" glb_wkdir=$glb_base; return 0
    fi

    if [ $# -ge 1 ] && [ -n "${cfg_projects[$1]+1}" ]; then
        declare -gr glb_prj="$1" glb_wkdir=${cfg_projects[$1]}; return 0
    else
        declare -gr glb_prj="dev" glb_wkdir=$glb_base; return 1
    fi
}

#
# Prepare command files
# Usage:
#     dev_cmd <cmd-file> <cmd-func>
#
dev_cmd() {
    [ ! -z "$glb_func"] && return 1

    if [[ $# -le 0 || -z "$1" ]]; then
        dev_help_usage >&2; dev_help_options >&2; dev_help_projects >&2; return 1
    fi

    if ! dev_load_files $glb_wkdir $1; then
        echo "Command file not found: $glb_wkdir/cmd/$1.cmd" >&2; return 1
    fi

    if [[ $# -eq 1 || -z "$2" ]]; then
        echo "Missing command function" >&2; echo >&2; dev_help_projects $@ >&2; return 1
    fi

    glb_file="$1"; glb_func="$2"; return 0
}

#
# Set execution function
#
dev_func() {
    if [ ! -z "$glb_func" ]; then
        echo "Error: \$glb_func has a value: $glb_func" >&2; return 1
    else
        glb_func="$1"
    fi
}

#
# Set run state
#
dev_run() {
    if [[ "$glb_run" -eq 1 ]]; then
        glb_run="$1" return 0
    else
        echo "Error: \$glb_run has a value: $glb_run" >&2; return 1
    fi
}

#
# Usage:
#     dev_load_files <prj> <cmd-file>
#
dev_load_files() {
    declare wkdir="$1" cf="$2"
    [ -f $wkdir/lib/bootstrap ] && . $wkdir/lib/bootstrap
    [ -f $wkdir/etc/dev.cmd/$cf.conf ] && . $wkdir/etc/dev.cmd/$cf.conf
    [ -f $wkdir/cmd/$cf.var ] && . $wkdir/cmd/$cf.var
    [ ! -f $wkdir/cmd/$cf.cmd ] && return 1 || . $wkdir/cmd/$cf.cmd
}

#
# Execute the command
# Usage:
#     dev_real_run <cmd-file> <cmd-func> [cmd-args]
#
dev_real_run() {
    declare cmd="" func=${glb_func/-/_}

    [[ "${func:0:4}" == "cmd_" || -z "$glb_file" ]] || func="cmd_$func"
    if [[ "$(declare -F $func)" != "$func" ]]; then
        echo "Command not found: $func" >&2; return 1
    fi

    if [[ $glb_run -le 2 ]]; then
        # Run in local machine
        dev_exec_local $func $@
    else
        dev_exec_remote $glb_base/bin/dev $glb_prj $glb_file $func $@
    fi
}

#
# Execute a command from all nodes.
# Usage:
#     dev_exec_remote dev [options] <cmd-file> <cmd-func> [cmd-args]
#
dev_exec_remote() {
    if [[ "${#glb_run_nodes[@]}" -le 0 ]]; then
        echo "Nodes is empty" >&2; return 1
    fi

    declare cmd user host

    for host in "${!glb_run_nodes[@]}"; do
        user="${glb_run_nodes[$host]}"
        cmd="ssh -i $glb_ssh_key -o StrictHostKeyChecking=no $user@$host"
        [ $glb_run_sudo -eq 1 ] && cmd="$cmd sudo"

        set +o errexit
        dev_exec $host $user $cmd $@
        set -o errexit

        echo
    done
}

#
# Usage:
#     dev_exec_local <command> <arguments>...
#
dev_exec_local() {
    declare host="127.0.0.1" user="$(whoami)" cmd
    cmd="$host $user"
    [ $glb_run_sudo -eq 1 ] && cmd="$cmd sudo $glb_base/bin/dev $glb_prj $glb_file"
    dev_exec $cmd $@
}

#
# Usage:
#     dev_exec <host> <user> <command> <arguments>...
#
dev_exec() {
    declare cmd log_out
    declare host="$1"; shift
    declare user="$1"; shift
    declare desc="[$user@$host $(date '+%Y-%m-%d %H:%M:%S')]"

    log_out="$glb_wkdir/var/log/$host.out"

    cmd="$@"

    if [ $glb_run_compact -eq 0 ]; then
        echo "$desc" >>$log_out
        echo "$cmd"; echo "$cmd" >>$log_out
        chmod a+wx $log_out
    fi

    [ $glb_run_dry -eq 1 ] && return 0

    if [ $glb_run_daemon -eq 1 ]; then
        nohup $cmd >>$log_out 2>&1 &
        echo "PID: $!"
    else
        $cmd 2>&1 | tee -a $log_out
    fi
}

#
# A function called main is required for scripts long enough to contain at
# least one other function.The last non-comment line in the file should be
# a call to main: dev_main "$@"
#
dev_main() {
    declare opt func args argv shft

    # Prepare optional arguments
    while true ; do
        opt=""; argv=""; shft="true"
        if [[ "$1" == "--" || "$1" == "-" ]]; then
            shift; break
        elif [[ "${1:0:2}" == "--" ]]; then
            opt="${1:2}"; shift
        elif [[ "${1:0:1}" == "-" ]]; then
            [ -z "${opa_als[${1:1}]}" ] && opt="${1:1}" || opt="${opa_als[${1:1}]}"; shift
            [ -z "$opt" ] && echo "Unrecognized option -${1:1}" >&2
        else
            break
        fi

        [ -z $opt ] && continue

        if [[ "$(expr index $opt '=')" -ge 1 ]]; then
            IFS='=' read -ra args <<< "$opt"
            opt="${args[0]}"; argv="${args[1]}";
        elif [[ ! -z "$1" && "${1:0:1}" != "-" ]]; then
            argv="$1"; shft="shift"
        fi

        func="opa_fun_${opt/-/_}"
        if [[ "$(declare -F $func)" == "$func" ]]; then
            $func $argv || $shft
        fi
    done

    # Do command function
    [ $glb_run -lt 1 ] && return 0

    if [ -z "$glb_func" ]; then
        [[ "$glb_run" -ge 1 && "${#glb_run_nodes[@]}" -gt 0 ]] && glb_run="3"
        dev_prj $@ && shift; dev_cmd $@ || return 1; shift 2
    else
        # The default project is dev
        dev_prj || true
    fi

    dev_real_run "$@"
}

# Call to main function. custom function declare before here.
dev_base; dev_main $@
